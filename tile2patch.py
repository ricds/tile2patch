# -*- coding: utf-8 -*-
"""
/***************************************************************************
 tile2patch
                                 A QGIS plugin
 create patches from tiles
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-10-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Ricardo Dalangol
        email                : ricds@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import * # QgsProject, QgsVectorLayer, QgsFeatureRequest, QgsVectorLayerUtils, QgsSymbolV2, QgsSingleSymbolRendererV2, QgsSimpleFillSymbolLayerV2
from qgis.utils import iface
from qgis import processing
import os

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .tile2patch_dialog import tile2patchDialog
import os.path


class tile2patch:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'tile2patch_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&tile2patch')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('tile2patch', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        # to update icon in qgis, update resources.qrc file manually, then run this command below in 'cmd' to create the resources.py
        # pyrcc5 -o resources.py resources.qrc

        icon_path = ':/plugins/tile2patch/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'tile2patch'),
            callback=self.run,
            parent=self.iface.mainWindow())

        icon_config = ':/plugins/tile2patch/icon2.png'
        self.add_action(
            icon_config,
            text=self.tr(u'tile2patch config'),
            callback=self.config,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&tile2patch'),
                action)
            self.iface.removeToolBarIcon(action)


    def config(self):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = tile2patchDialog()
            
        # show the dialog
        self.dlg.show()
        

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = tile2patchDialog()

        """
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        """
        
        result = True;
        
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.

            """
            # Fetch the currently loaded layers
            layers = QgsProject.instance().layerTreeRoot().children()
            
            # Clear the contents of the comboBox from previous runs
            self.dlg.comboBox.clear()
            # Populate the comboBox with names of all the loaded layers
            self.dlg.comboBox.addItems([layer.name() for layer in layers])
            """
            
            # function to remove layers
            def rmLayer(lyrname):
                qinst = QgsProject.instance()
                layer = qinst.mapLayersByName(lyrname)[0]
                qinst.removeMapLayer(layer.id())
                
           
            # check if field exists in the shapefile
            shpAttributeName = self.dlg.shpAttributeBox.text()
            #field_name = "name"
            field_name = shpAttributeName
            layer = iface.activeLayer() # Gives you the layer you have selected in the Layers Panel
            print(layer)
            
            # determine if we have anything selected
            haveSelection = len(layer.selectedFeatureIds()) > 0

            # check if object is vector
            proceed = False;
            if isinstance(layer, QgsVectorLayer):
                field_index = layer.fields().indexFromName(field_name)
                # check if we have the correct attribute
                if field_index == -1:
                    #print("The field {} does not exist in layer {}!".format(field_name, layer.name()))
                    proceed=False;
                else: 
                    #print("The field {} exists in layer {}!".format(field_name, layer.name()))
                    if haveSelection:
                        proceed=True;
            print(proceed);

            # proceed only if we have the correct shapefile with the 'name' attribute
            if proceed:

                # get available layers
                layer = iface.activeLayer()
                crs = layer.crs().toWkt()
                #print(crs)
                print(layer)

                # creates a memory layer of original layer exclusively with all selected features in it
                temp_layer = layer.materialize(QgsFeatureRequest().setFilterFids(layer.selectedFeatureIds()))
                print(temp_layer)
   
                # specify your target field
                #result = QgsVectorLayerUtils.getValues(temp_layer, "name")[0]
                result = QgsVectorLayerUtils.getValues(temp_layer, shpAttributeName)[0]

                # print name of the tile
                print(result)
                
                # stop running code if we have nothing selected
                if len(result[0]) == 0:
                    exit()

                # check if this grid is not already on the layer list
                ## this piece of code is limited because it only checks one, so we get bug if more than one is selected and previously gridded
                layer_name = 'grid_' + result[0]
                # Check if a layer with the given name exists
                layer_exists = QgsProject.instance().mapLayersByName(layer_name)

                # if grid already exists we do nothing
                if layer_exists:
                    pass;
                else:

                    # create attribute in combobox to get all the items
                    setattr(self.dlg.comboBox, "allItems", lambda: [self.dlg.comboBox.itemText(i) for i in range(self.dlg.comboBox.count())])
                    
                    # get data from the UI
                    last_grid = self.dlg.comboBox.currentText()
                    n_tiles = int(self.dlg.ntilesBox.text())
                    gridColor = self.dlg.gridColorBox.text()
                    deletePrevious = self.dlg.deletePreviousBox.isChecked()
                    last_layer_active = self.dlg.comboBox.allItems()
                    print(last_layer_active)
                                
                    # delete layers created last time
                    loaded_layer_names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
                    #print(loaded_layer_names)
                    if deletePrevious:
                        # Iterate through the list of layer names
                        for layer_name in last_layer_active:
                            # Check if the layer name exists in the list of loaded layers
                            if layer_name in loaded_layer_names:
                                rmLayer(layer_name)
                    
                    # clear combobox
                    self.dlg.comboBox.clear()
                    
                    # iterate through features to create
                    for feature in temp_layer.getFeatures():
                        #print(feature["name"])
                        print(feature[shpAttributeName])
                        # get extent of selected tile
                        extent = feature.geometry().boundingBox()
                        #extent = temp_layer.extent()
                        #print(extent)
                        xmin = extent.xMinimum()
                        xmax = extent.xMaximum()
                        ymin = extent.yMinimum()
                        ymax = extent.yMaximum()
                        ext_str = str(xmin) + ',' + str(xmax) + ',' + str(ymin) + ',' + str(ymax)
                        #print(ext_str)
                        hsp = (xmax - xmin)/n_tiles
                        vsp = (ymax - ymin)/n_tiles
                        #print(hsp)
                        #print(vsp)

                        # get crs of the selected layer
                        #crs = temp_layer.crs().toWkt()
                        #print(crs)

                        # run grid
                        #crs = QgsProject().instance().crs().toWkt() # it is EPSG:3857
                        params = {'TYPE':2,
                                  #'EXTENT':'2308576.5177,2336787.5621,54157.4399,66396.9190',
                                  'EXTENT':ext_str,
                                  #'HSPACING':1221.12,
                                  #'VSPACING':1221.12,
                                  'HSPACING':hsp,
                                  'VSPACING':vsp,
                                  'HOVERLAY':0,
                                  'VOVERLAY':0,
                                  'CRS':crs,
                                  'OUTPUT':'grid_' + feature[shpAttributeName]}
                                  #'OUTPUT':'grid_' + feature["name"]}
                                  #'OUTPUT':'grid_' + result[0]}
                        out1 = processing.run('native:creategrid', params)

                        # add to layers
                        #grid = QgsVectorLayer(out1['OUTPUT'], 'grid_' + feature["name"], 'ogr')
                        grid = QgsVectorLayer(out1['OUTPUT'], 'grid_' + feature[shpAttributeName], 'ogr')
                        QgsProject().instance().addMapLayer(grid)
                        
                        # Create the symbol with the specified properties
                        symbol_dict = {
                            'color': 'black',
                            'style': 'no',
                            'outline_color': gridColor,  # Replace with the desired outline color
                            'outline_width': 0.25  # Replace with the desired outline width
                        }
                        symbol = QgsSymbol.defaultSymbol(grid.geometryType())
                        symbol_layer = QgsSimpleFillSymbolLayer.create(symbol_dict)
                        symbol.changeSymbolLayer(0, symbol_layer)

                        # Apply the symbol to your vector grid
                        grid.renderer().setSymbol(symbol)
                        
                        # Annotate the grid name in the box
                        self.dlg.comboBox.addItems([grid.name()])
    
            
            
